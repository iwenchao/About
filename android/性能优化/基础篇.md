### 磁盘
##### bitmap
### 网络
一个网络请求可以简单分为连接服务器 -> 获取数据两个部分。
其中连接服务器前还包括 DNS 解析的过程；获取数据后可能会对数据进行缓存。
##### 连接服务器优化策略
1. **不用域名，用 IP 直连**。 省去 DNS 解析过程，首次域名解析一般需要几百毫秒，可通过直接向 IP 而非域名请求，节省掉这部分时间，同时可以预防域名劫持等带来的风险。当然为了安全和扩展考虑，这个 IP 可能是一个动态更新的 IP 列表，并在 IP 不可用情况下通过域名访问。
2. **服务器合理部署**。
    - 服务器多运营商多地部署，一般至少含三大运营商、南中北三地部署。
    - 动态 IP 列表，支持优先级，每次根据地域、网络类型等选择最优的服务器 IP 进行连接
    - 对于服务器端还可以调优服务器的 TCP 拥塞窗口大小、重传超时时间(RTO)、最大传输单元(MTU)等。

##### 获取数据优化策略
1. 连接复用[参考资料](http://blog.51cto.com/gaibianziji/1211940)
    - 节省连接建立时间，如开启 keep-alive。
2. 请求合并
    - 即将多个请求合并为一个进行请求，比较常见的就是网页中的 CSS Image Sprites。 如果某个页面内请求过多，也可以考虑做一定的请求合并。
3. 减少请求大小
    - 对于 POST 请求，Body 可以做 Gzip 压缩，如日志。
    - 对请求头进行压缩：这个 Http 1.1 不支持，SPDY 及 Http 2.0 支持。 Http 1.1 可以通过服务端对前一个请求的请求头进行缓存，后面相同请求头用 md5 之类的 id 来表示即可。
4. CDN缓存静态资源
    - 缓存常见的图片、JS、CSS 等静态资源。
5. 减少返回数据的大小
    - 压缩：一般 API 数据使用 Gzip 压缩
    - 精简数据格式
    - 对于不同的设备不同网络返回不同的内容 如不同分辨率图片大小。
6. 增量更新
    - 需要数据更新时，可考虑增量更新。如常见的服务端进行 bsdiff，客户端进行 bspatch。



### 内存
#### 1. java内存相关；
##### 内存区域划分；
```
1. 堆 : 
    - java中运行环境用来分配给对象和JRE类的内存都在堆内存，C、C++有时候malloc或者new来申请分配内存也在这里； 
    -  不连续内存区域，容易造成内存碎片，不易管理 
    -  所有线程共享的内存区域
2. 栈 :   
    - 相对于线程而言，执行函数时，内部变量以及对堆中对象的引用都可以在栈中，函数执行结束后就会释放这些
    - 一块连续的内存区域，先进后出，不会产生碎片，运行效率高而稳定
    - 本地方法栈和虚拟机栈，虚拟机栈为执行java代码方法服务；本地方法栈为执行native方法服务。同样都会抛出StackOverflow和OutOfMemory
    - 虚拟机栈：java方法执行的内存模型，和线程有相同的生命周期，线程私有；其中的一些关键词汇： 栈帧，局部变量表，操作数栈，指向当前方法所属的类的运行时常量池的引用，方法返回地址和一些额外的附加信息
3. 方法区 :
    - 存放类信息，常量，静态变量等；
    - 因为反射机制的原因，虚拟机很难推测哪个类信息不再使用，因此这块区域的回收很难。对这块区域主要是针对常量池回收
    - 所有线程共享的区域
    -当方法区无法满足内存需求时会抛出 OutOfMemoryError 异常
4. 运行时常量池 :
    - 是方法区的一部分，用于存放编译期生成的各种字面量和符号。
    - 避免了频繁的创建和销毁对象而影响系统性能，实现了对象的共享，节省了内存空间和运行时间。
    - 值得说明的是，运行时常量池具备动态特性，常量不止在编译期可以产生，在运行期间也可以产生，比如String的intern方法。
5. 程序计数器 
    - 当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成

```

##### 2. 作为gc root常见的有：
```
官方解释：JVM中GC Roots的大致分类
1. Class 由System Class Loader/Boot Class Loader加载的类对象，这些对象不会被回收。需要注意的是其它的Class Loader实例加载的类对象不一定是GC root，除非这个类对象恰好是其它形式的GC root；

2. Thread 线程，激活状态的线程；

3. Stack Local  栈中的对象。每个线程都会分配一个栈，栈中的局部变量或者参数都是GC root，因为它们的引用随时可能被用到；

4. JNI Local JNI中的局部变量和参数引用的对象；可能在JNI中定义的，也可能在虚拟机中定义

5. JNI Global JNI中的全局变量引用的对象；同上

6. Monitor Used 用于保证同步的对象，例如wait()，notify()中使用的对象、锁等。

Held by JVM JVM持有的对象。JVM为了特殊用途保留的对象，它与JVM的具体实现有关。比如有System Class Loader, 一些Exceptions对象，和一些其它的Class Loader。对于这些类，JVM也没有过多的信息

1. 虚拟机栈中引用的对象
2. 方法区中类的静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（即一般说的Native方法）引用的对象
总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象
```



##### 3. java中的引用划分；
1. 强引用：
    - new出来的对象；
    - Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题
2. 软引用：
    - 如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存 空间不足了，就会回收这些对象的内存
    - 软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联 的引用队列中。
3. 弱引用：
    - 如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更 短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
    - 由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象
    - 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联 的引用队列中
4. 虚引用：
    - 虚引用并不会决定对象的生命周期。如果一个对象 仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
    - 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队 列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

##### 4. 什么是内存泄漏？ 常见的泄漏场景有哪些？
1. 内存泄漏：在安卓中内存泄露常常出现的情况是指组件生命周期已经结束，但是其引用被其他更长声明周期的对象持有，得不到释放引起的。
2. 泄漏场景：
    - 内部类，java中非静态内部类持有外部类的引用
    - 静态变量，更长声明周期的静态变量引用短周期的对象。android开发中应该尤其注意context的引用链；保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期
    - 耗时类泄漏，比如在短生命周期中创建了更长生命周期的耗时操作对象，在未结束之前，使得一直保持对短生命周期对象的引用；解决方式：①使用弱引用；②使用解耦的方式，使得长短生命周期的对象，可以在生命周期结束时及时释放
    - Handler引起，尽量使用静态handler或者单独继承handler的类文件，然后持有上下文的弱引用；使用post系列方法是，runnable也尽量使用静态；在页面销毁的时候，需要removeCallbacks取消所有的消息
    - 单例，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用
    - 属性动画，及时cancel掉
    - 资源未关闭造成：对于使用了BraodcastReceiver，ContentObserver，File， Cursor，Stream，Bitmap, EventBus等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。
3. 
### UI
### 电量