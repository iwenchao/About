####  序列化
0. 为什么需要序列化与反序列化？
    - 当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。
    - 那么进程间如何传递一个对象呢？这个就需要使用到序列化与反序列化机制了。一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。
    - 其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。
    - 相关注意点：
        1. 序列化时，只对对象的状态进行保存，而不管对象的方法；
        2. 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；
        3. 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；
        4. 声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。
        5. 序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。

1. JAVA中的Serialize机制
    - 其作用是能**将数据对象存入字节流**当中，在需要时重新生成对象。主要应用是利用外部存储设备保存对象状态，以及通过网络传输对象等。
    - （1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中； 
    - （2）通过序列化以字节流的形式使对象在网络中进行传递和接收； 
    - （3）通过序列化在进程间传递对象；

2. Android中的Parcel
    - 其定位就是轻量级的高效的对象序列化和反序列化机制
    - 原理：Parcel提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过Parcel可以从这块共享内存中读出字节流，并反序列化成对象,
    - 有以下几个特征
        1. 整个读写全是在内存中进行，所以效率比JAVA序列化中使用外部存储器会高很多；
        2. 读写时是4字节对齐的
        3. 如果预分配的空间不够时，会一次多分配50%；
        4. 对于普通数据，使用的是mData内存地址；
        5. 对于IBinder类型的数据以及FileDescriptor类型数据，使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。
使用Bundle传递对象，首先要将其序列化，但是，在Android中要使用这种传递对象的方式需要用到Android Parcel机制，即，Android实现的轻量级的高效的对象序列化和反序列化机制