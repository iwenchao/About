### 数据结构的种类
1. 数组 Array
    - 典型问题
        - 查找数组中第二小的元素
        - 查找第一个没有重复的数组元素
        - 合并2个排序好的数组
        - 重新排列数组中的正数和负数

2. 栈 Stack
    - 基于数组
    - 典型问题
        - 使用栈计算后缀表达式
        - 使用栈为栈中的元素排序
        - 检查字符串中的括号是否匹配zhengque


3. 队列 Queue
    - 基于数组的线性结构，采用先进先出FIFO
    - Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它
    - 典型问题
        - 使用队列实现栈
        - 倒转队列的前K个 元素
        - 使用队列将1到n转换为二进制
4. 链表
    - 线性结构，由一系列的节点组成的链，每一个节点保存了数据以及指向下一个节点的指针。链表头指针指向第一个节点，如果链表为空，则头指针为空或者为null。
    - 链表可以用来实现**文件系统**、**哈希表**和**邻接表**。
    - 单向链表，双向链表
    - 典型问题
        - 倒转一个链表
        - 检查链表中是否存在循环
        - 返回链表中倒数第N个元素
        - 移除链表中的重复元素
5. 图
    - 由多个节点(vertex)构成，节点之间阔以互相连接组成一个网络。(x, y)表示一条边(edge)，它表示节点x与y相连。边可能会有权值(weight/cost)。
    - 有向图，无向图
    - 在编程里，图可能有以下两种形式表示
        - 邻接矩阵
        - 邻接表
    - 遍历图 有两种算法（搜索算法）
        - 深度优先搜索
        - 广度优先搜索
    - 典型问题
        - 实现广度优先搜索
        - 实现深度优先搜索
            - 前序遍历：根节点->左子树->右子树
            - 中序遍历：左子树->根节点->右子树
            - 后序遍历：左子树->右子树->根节点
        - 检查图是否为树
        - 统计图中边的个数
        - 使用Dijkstra算法查找两个节点之间的最短距离
        
6. 树
    - 树(Tree)是一个分层的数据结构，由节点和连接节点的边组成。树是一种特殊的图，它与图最大的区别是没有循环。
    - 树被广泛应用在人工智能和一些复杂算法中，**用来提供高效的存储结构**。
    - 分类：
        - N叉树
        - 平衡树
        - **二叉树**： 它的特点是每个结点至多只有两颗子树(即二叉树中不存在度大于2的结点), 并且,二叉树的子树有左右之分, 其次不能任意颠倒.
        - **二叉查找树**
        - 平衡二叉树,又被称为AVL树。它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
        - **红黑树**
        - 2-3树
    - 典型问题
        - 计算树的高度
        - 查找二叉平衡树中第k大的元素
        - 查找树种与根节点距离为k的节点
        - 查找二叉树中某个节点所有祖先节点
7. 前缀树
    - 前缀树(Prefix Trees或者Trie)与树类似，用于处理字符串相关的问题时非常高效。它可以实现快速检索，**常用于字典中的单词查询，搜索引擎的自动补全甚至IP路由**。
    - 典型问题
        - 统计前缀树表示的单词个数
        - 使用前缀树为字符串数组排序
8. 哈希表
    - 将某个对象变换为唯一标识符，该标识符通常用一个短的随机字母和数字组成的字符串来代表。哈希可以用来实现各种数据结构，其中最常用的就是哈希表(hash table)。
    - 哈希表通常由**数组**实现
    - 哈希表的性能取决：
        - 哈希函数
        - 哈希表的大小
        - 哈希冲突的处理方式
    - 典型问题
        - 查找数组中对称的组合
        - 确认某个数组的元素是否为另一个数组元素的子集
        - 确认给定的数组是否互斥


















### 红黑树
1. 是一种近似平衡二叉树，他能够确保任何一个节点的左右子树的高度差都不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉树
    - 每个节点要么是红色，要么是黑色；
    - 根节点必须是嘿色
    - 红色节点不能连续（即红色节点的孩子和父亲都不能是红色节点）
    - 对于每个节点，从该点到null（树末端）的任何路径，都含有相同个数的黑色节点

2. 当发生插入或删除节点的时候，以上条件就会被破坏。需要重新调整
    - ①颜色调整：即改变某个节点的颜色
    - ②结构调整：即改变检索树的结构关系。 结构调整包含两个基本操作（左旋，右旋）
        - 左旋：将节点x的右子树逆时针旋转，使得x的右子树成为x的父节点，同时修改相关节点的引用
        ```
            public void rotateLeft(Entry<K,V> p){
                if(p != null){
                    Entry<K,V> rNode = p.right;
                    p.right = rNode.left;
                    if(rNode.left != null){
                        p.right = rNode.left;
                    }
                    rNode.parent = p.parent;
                    if(p.parent != null){
                        root = rNode;
                    }else if(p.parent.left == p){
                        p.parent.left = rNode;
                    }else{
                        p.parent.right = rNode;
                    }
                    rNode.left = p;
                    p.parent = rNode;
                }
            }

        ```
        - 右旋：将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。
        ```
            private void rotateRight(Entry<K,V> p) {
                if (p != null) {
                    Entry<K,V> l = p.left;
                    p.left = l.right;
                    if (l.right != null) l.right.parent = p;
                    l.parent = p.parent;
                    if (p.parent == null)
                        root = l;
                    else if (p.parent.right == p)
                        p.parent.right = l;
                    else p.parent.left = l;
                    l.right = p;
                    p.parent = l;
                }
            }
        ```