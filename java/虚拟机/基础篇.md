
### java虚拟机
JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。

##### 关于并发编程
在并发编程领域，有两个关键问题：线程之间的通信和同步。

###### 线程之间的通信
线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种**共享内存**和**消息传递**。

在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过**写-读内存中的公共状态**来隐式进行通信，典型的共享内存通信方式就是通过**共享对象**进行通信。

在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的**发送消息**来显式进行通信，在java中典型的**消息传递方式就是wait()和notify()**。


###### 线程之间的同步
同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。

在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

###### Java的并发采用的是共享内存模型
Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。


### Java内存模型
上面讲到了Java线程之间的通信采用的是过**共享内存模型**，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化**。

###### JVM对Java内存模型的实现
Java内存模型把内存分成了两部分：线程栈区和堆区

JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。

线程栈还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈

所有原始类型(boolean,byte,short,char,int,long,float,double)的本地变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。

堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。


一个本地变量如果是原始类型，那么它会被完全存储到栈区。 
一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。

对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。 
对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。


Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。

堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。


### 硬件内存架构

1. CPU
    - cpu register  一级缓存
2. CPU Cache 二级缓存
3. RAM 主内存 三级缓存

当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存

### 共享对象的可见性
当多个线程同时操作同一个共享对象时，如果没有合理的使用volatile和synchronization关键字，一个线程对共享对象的更新有可能导致其它线程不可见。

volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的

synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。

### 支撑Java内存模型的基础原理
1. 指令重排序：在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。（内存屏障：又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：保证特定操作的执行顺序。影响某些数据（或则是某条指令的执行结果）的内存可见性。）

    1. 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
    2. 指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
    3. 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。


### 内存模型以及分区，需要详细到每个区放什么。
1. 程序计数器、
    - 一块较小的内存空间，它是当前线程所执行的字节码的行号指示器
    - 字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。
    - 每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。
2. Java虚拟机栈、
    - 该区域也是线程私有的，它的生命周期也与线程相同。
    - 描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。
    - 对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。
    - 栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
3. 本地方法栈、
    - 该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。

4. 方法区。
    - 线程共享内存
    - 用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
    - 该区域的内存回收目标主要针是对废弃常量的和无用类的回收。
    - 运行时常量池
        - 运行时常量池是方法区的一部分
        - 用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中
    - 运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

5. Java堆、
    - 是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。
    - Java Heap是垃圾收集器管理的主要区域


### 内存泄漏与内存溢出
泄漏是指：分配出去的内存被无用对象占用，无法及时回收； 
溢出是指：程序所需要分配的内存超出了系统所能分配的内存的上限

### 类型擦除
Java语言在JDK1.5之后引入的泛型实际上只在程序源码中存在，在编译后的字节码文件中，就已经被替换为了原来的原生类型，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<String>和ArrayList<Integer>就是同一个类。所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型。
```
    public void method(List<String> list){  
            System.out.println("List String");  
        }  
        public void method(List<Integer> list){  
            System.out.println("List Int");  
        }  
```
用Javac编译器编译这段代码时，报出了如下错误:名称冲突：method

这是因为泛型List和List编译后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样，在**Class类文件结构**一文中讲过，Class文件中不能存在**特征签名**相同的方法。

我们知道，**Java代码中的方法特征签名**只包括了方法名称、参数顺序和参数类型，并不包括方法的返回值，因此方法的返回值并不参与重载方法的选择，这样看来为重载方法加入返回值貌似是多余的。对于重载方法的选择来说，这确实是多余的，但我们现在要解决的问题是让上述代码能通过编译，让两个重载方法能够合理地共存于同一个Class文件之中，这就要看**字节码的方法特征签名**，它不仅包括了Java代码中方法特征签名中所包含的那些信息，还包括方法返回值及受查异常表。为两个重载方法加入不同的返回值后，因为有了不同的字节码特征签名，它们便可以共存于一个Class文件之中。


### 对象创建方法，对象的内存分配，对象的访问定位。
```
Object obj = new Object();
```
这段代码的执行会涉及java栈、Java堆、方法区三个最重要的内存区域。
1. 假如在方法体中： 
    - obj引用 存放在java栈中的本地变量表
    - obj引用持有的对象，存放在java堆中，
    - 另外java堆中还必须包含能够查找到此对象类型数据的地址信息（对象类型，父类，接口，方法，字段，等），这些静态信息被存放在方法区
2. 关于引用
由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：**使用句柄池**和直接**使用指针。**

### GC的两种判定方法： 引用计数与引用链
### GC的三种收集方法：标记清除，标记整理，复制算法

