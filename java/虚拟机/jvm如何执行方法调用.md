---
title: jvm的执行方法调用
---


#### jvm区分方法
针对方法执行，方法重载，方法重写而言，在java编译器以及jvm是如何区分方法的？然后执行具体类型的方法？区分方法分为重载方法，和重写方法。方法重载在编译期就确定下来了，而方法重写在运行时确定。

1. 区分重载方法
    - 重载方法在编译过程中即可完成识别，具体到每一个方法调用，Java 编译器会根据所传入的参数的声明类型来选取重载方法，选取的过程分为三个阶段：
        1. 在不考虑对基本类型自动装拆箱、以及可变长参数的情况下选取重载方法
        2. 如果在第一个阶段没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选择重载方法
        3. 如果在上两个阶段都没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法
    如果 Java 编译器在同一个阶段找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而**决定贴切程度的一个关键就是形式参数类型的继承关系**。

2. java的识别方法：
    - JVM 识别方法的关键在于类名、方法名以及方法描述符。前面两个就不做过多解释了，至于方法描述符，它是由方法的参数类型以及返回类型所构成。这也是方法重写所要求的。
    - 由于对重载方法的区分在编译阶段已经完成，所以可以认为在 JVM 不存在重载这一概念，因此，在某些文章中，重载也被称为静态绑定，或者编译时多态，而重写则被称为动态绑定。
    - 这个说法在 JVM 语境下并非完全正确，这是因为某个类中的重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。
    - 确切的说，Java 虚拟机中的静态绑定指的是在解析时便能够**直接识别**目标方法的情况，而动态绑定则指的是需要在运行过程中根据**调用者的动态类型**来识别目标方法的情况。

 3. Java 字节码中与调用相关的指令共有五种：
    1. invokestatic : 用于调用静态方法
    2. invokespecial : 用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所有实现接口的默认方法
    3. invokevirtual : 用于调用非私有实例方法
    4. invokeinterface : 用于调用接口方法
    5. invokedynamic : 用于调用动态方法

    对于 invokestatic 以及 invokespecial 而言，Java 虚拟机能够直接识别具体的目标方法。而对于 invokevirtual 和 invokeinterface 而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。

    唯一例外在于，如果虚拟机能够确定目标方法有且只有一个，比如方法被 final 修饰，那么它就可以不通过动态类型，直接确定目标方法。

4. 虚方法调用

在上面讲到，Java 里所有非私有实例方法调用都被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令，这两种指令，均属于 Java 虚拟机中的虚方法调用。

Java 虚拟机需要根据**调用者的动态类型**，来确定虚方法调用的目标方法，这个过程我们称为动态绑定。相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。

ava 虚拟机采用了一种用**空间换时间**的策略来实现动态绑定，它为**每个类生成一张方法表**，用以快速定位目标方法。

5. 方法表
    - 在**类加载的准备阶段**，除了为静态字段分配内存之外，还会构造与该类相关联的方法表。方法表是 JVM 实现动态绑定的关键所在。
    - 方法表本质上是一个数组，每个数组元素**指向一个当前类及其祖先类中非私有的实例方法**。
    - 满足两个特性：
        1. 子类方法表中包含父类方法表中的所有方法
        2. 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同
    - 我们知道，方法调用指令中的符号引用会**在执行之前解析成实际引用**。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值。
    - 实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解析引用操作，相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。
        1. 访问栈上的调用者，
        2. 读取调用者的动态类型，
        3. 读取该类型的方法表，
        4. 读取方法表中某个索引值所对应的目标方法
    
那么是不是就可以认为虚方法调用对性能没有太大影响呢？其实是不能的，上诉优化的效果看起来好不错，但实际上仅存于解释执行中，或者即时编译代码的最坏情况中。这是因为**即时编译JIT**还拥有另外两种性能更好的优化手段：**内联缓存和方法内联**。

5. 内联缓存
    - 内联缓存是一种加快动态绑定的优化技术。
    - 它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。
    - 虽然内联缓存附带内联两字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联，否则都会有固定开销。这些开销来源于**保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧**。
