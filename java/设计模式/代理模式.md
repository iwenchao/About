### 代理模式分析
#### 静态代理
- 编译期生成代理
- 代理的设计理念是限制对象的直接访问，即不能通过 new 的方式得到想要的对象，而是访问该对象的代理类。

- 代理类可以实现拦截方法，修改原方法的参数和返回值，满足了代理自身需求和目的，也就是是代理的方法增强性。

- 场景1. 海外代购的方式
    - Subject(抽象角色)：声明真实对象和代理对象的共同接口
    - ProxySubject(代理角色)：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。
    - (RealSubject)真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。调用 RealSubject 的方法，都要经过 ProxySubject 进行代理。

#### 动态代理
- 运行时生成代理类
    - 静态代理有一个缺点：
        - 需要对每一个对象，生成一个代理类。如果需要被代理的类很多，则会增加开发的复杂度以及可扩展性降低；
- 生成动态代理类有很多方式：Java动态代理，CGLIB，Javassist，ASM库等。这里主要说一下 Java 动态代理的实现。
- java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了**一组静态方法**来为**一组接口**动态地生成代理类及其对象。
    ```
    // 方法 1: 该方法用于获取指定代理对象所关联的调用处理器
    static InvocationHandler getInvocationHandler(Object proxy) 

    // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象
    static Class getProxyClass(ClassLoader loader, Class[] interfaces) 

    // 方法 3：该方法用于判断指定类对象是否是一个动态代理类
    static boolean isProxyClass(Class cl) 

    // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例
    static Object newProxyInstance(ClassLoader loader, Class[] interfaces, 
        InvocationHandler h)

    ```
- java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。 
    - ```
        // 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象
        // 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行
        Object invoke(Object proxy, Method method, Object[] args)
    ```
- java.lang.ClassLoader：这是类装载器类，负责将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。


#### 优缺点：
- 优点：
    1. 良好的扩展性。修改被代理角色并不影响调用者使用代理，对于调用者，被代理角色是透明的。
    2. 隔离，降低耦合度。代理角色协调调用者和被代理角色，被代理角色只需实现本身关心的业务，非自己本职的业务通过代理处理和隔离。
- 缺点：
    1. 增加了代理类，实现需要经过代理，因此请求速度会变慢。


#### 代理模式与装饰者模式的区别

UML类图基本没区别，都是实现同一个接口，一个类包装另一 个类。 两者的定义：

装饰器模式：能动态的新增或组合对象的行为 
在不改变接口的前提下，动态扩展对象的功能。

代理模式：为其他对象提供一种代理以控制对这个对象的访问 
在不改变接口的前提下，控制对象的访问

装饰模式是“新增行为”，而代理模式是“控制访问”。
