1. [基础篇1](https://juejin.im/post/5aa4bb1f6fb9a028b54781f4)
# 整理:

### java设计思想
1. 抽象
    1. 抽象类与接口的区别
2. 封装
3. 多态:
    1. 静态多态:重载,编译期
    2. 动态多态:重写,运行时
    3. 重写要求: 
        1. 父子类
        2. 方法名,与方法参数一致(参数个数,类型,顺序)
        3. 返回的数据类型必须是父类相同或者是其子类
        4. 访问修饰符必的限制必须要大于父类限制(public>protected>default>private)
    4. 重载要求:
        1. 方法名要相同
        2. 其他的,比如参数,返回类型,访问修饰符可以不同
4. 继承
    1. 内部类的区别
        1. 静态内部类
        2. 内部类
        3. 匿名内部类
    2. 内部类的作用
        1. 非静态内部类可以访问它的外部类对象的成员包括私有成员, 但是引用局部变量时,应该加final (为什么? 因为内部类和局部变量生命周期不同（方法结束后局部变量的生命周期就结束了，而内部类只要有引用就不结束，内部类的生命周期>=局部变量）  Java为了解决这一问题，会在编译时在内部类的构造方法里边，将局部变量作为参数传入内部类   这就造成了局部变量如果改变，内部类不知情的场景，所以要加final，保证引用不可改变   在java8中，可以不使用final关键字，但是如果我们改变局部变量的引用，编译会发生错误，从而保证了局部变量的引用不变。)
    3. 内部类持有外部类引用: 答 (内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的class文件，内部类通过this访问外部类的成员。
    编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象
    编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为内部类中添加的成员变量赋值；
    在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。
    )

### 静态变量与成员变量的区别
```
1. 静态变量属于类，被多个实例共享，成员变量属于实例
2. 静态变量储存在方法区，成员变量在堆
3. 静态变量在类加载时候存在，成员变量在实例加载之后存在
4. 静态方法可以直接使用静态变量，不能直接使用成员变量
```

### 抽像方法,是否可以同时是静态的?是否可以同时是本地方法?是否可以被synchronized修饰?
1. 抽象方法不能是静态的,静态方法不能被子类重写,抽象方法必须被子类重写
2. 抽象方法不能是本地的,本地方法是由本地代码实现,而抽象方法是没有具体实现
3. 抽象方法不能用synchronized修饰; synchronized和方法实现的具体细节有关

### 类加载与初始化的顺序
 创建对象时构造器的调用顺序是： 父类静态初始化块 -> 子类静态初始化块 -> 父类初始化块 ->调用了父类构造器 -> 子类初始化块 -> 调用子类的构造器


 ### java中的哪些关键字
 1. transient:用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程
 2. throws,throw,try,catch,finally
 3. final,finally,finalize
    1. final 修饰类,变量,方法 (类不能被继承,方法不可被重写,变量不可变)
    2. finally 异常捕获结构中; 该语句在及其特殊的情景下,可能不执行(调用了System.exit()方法;JVM崩溃了)
    3. finalize是Object中的方法,垃圾回收时会调用该方法.

### 自动装箱和自动拆箱
1. Integer与内部类IntegerCache(如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接**引用常量池**中的Integer对象)
2. char类型变量中能不能存储一个中文汉字?  答: char类型用来存储Unicode编码的字符,unicode编码字符集中包含了汉字,所以可以的

### String与StringBuilder,StringBuffer的区别
1. String: 只读,不可变; 在拼接String的时候,使用+编译器会帮我们进行优化
2. StringBuilder: 可变,线程不安全,效率高
3. StringBuffer: 可变,线程安全,效率低
```
        String s1 = "Programming";
        String s2 = new String("Programming");
        String s3 = "Program";
        String s4 = "ming";
        String s5 = "Program" + "ming";
        String s6 = s3 + s4;
        System.out.println(s1 == s2); // false
        System.out.println(s1 == s5); //true
        System.out.println(s1 == s6); //false
        System.out.println(s1 == s6.intern()); //true
        System.out.println(s2 == s2.intern()); //false
解析：1. String是引用类型，这里 == 比较的是引用是否相同，即是否指向相同的地址
     2. 在new String对象时，会产生一个新的对象，并不会使用常量池中的字符串
     3. intern会在常量池中寻找该字符串（如果没有责新建），并返回他的地址

 String s = new String("xyz");创建了几个字符串对象？
 答: 两个对象，一个是静态区的"xyz";一个是用new创建在堆上的对象。
```
3. String为什么设计成不变的? 
    1. 线程安全,不可变天生线程安全
    2. String常被用作HashMap的key，如果可变会引有安全问题，如两个key相同
    3. String常被用作数据库或接口的参数，可变的话也会有安全问题
    4. 效率: 字符串池可以节省很多空间
    5. 效率: 每个String对应一个hashcode,再次使用的话不用重新计算

### java中的编码
##### 为什么需要编码
1. 因为计算机存储信息的最小单元是一个字节 即8bit,所以能表示的范围是0~255,这个范围是无法保存所有的字符,所以需要一个新的数据结构char来表示这些字符,从char到byte需要编码.
##### 常见的编码
1. ASCII : 总共有 128 个，用一个字节的低 7 位表示，031 是控制字符如换行回车删除等；32126 是打印字符，可以通过键盘输入并且能够显示出来
2. GBK: 码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。
3. UTF-16 :UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，**这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因**。
4. UTF-8:统一采用两个字节表示一个字符，虽然在表示上非常简单方便，**但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量**，而且也没必要。而 **UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度**。不同类型的字符可以是由 1~6 个字节组成。

##### java中需要编码的地方,一般都是在字符和字节的转换上,包括磁盘IO和网络IO
```
Reader类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。

```
##### Unicode与UTF-8的关系: unicode是字符集utf-8的一种编码方式,达到了对数据流压缩的目的

### 字节流与字符流的区别
1. 字节流操作的都是字节byte, 字符流操作的都是Unicode字符
2. 字节流不使用缓冲区, 字符流使用缓冲区 buffer
3. 字节流通常用于处理二进制数据,实际上他可以处理任何类型的数据, 但它不支持直接写入或者读取Unicode码元; 字符流通常处理文本数据,它支持写入以及读取Unicode码元

### IO与NIO的区别
1. io面向流, nio面向缓冲区
2. io是阻塞的, nio是非阻塞的? 有哪些方式处理非阻塞? TODO
3. java nio的选择器允许一个单独的线程来监视多个输入通道,你可以注册多个通道使用一个选择器,然后使用一个单独的线程来"筛选"通道; 这些通道里有已经可以处理的输入,或者选择已准备写入的通道. 
```
1. 大文件的赋值: 利用NewIO的FileChanel
```
### java中如何实现序列化? 有哪些意义?
1. 序列化是将对象的状态信息转换为可以存储或传输的形式的过程
2. java将对象序列化成了字节信息
3. java通过Serializeable接口实现序列化

### java中四种引用以及应用场景
1. 强引用: 通常我们使用new操作符创建一个对象时所返回的引用即为强引用
2. 弱引用: 若一个对象只能通过弱引用到达，那么它就会被回收（即使内存充足），同样可用于图片缓存中，这时候只要Bitmap不再使用就会被回收
3. 软引用: 若一个对象只能通过软引用到达，那么这个对象在内存不足时会被回收，可用于图片缓存中，内存不足时系统会自动回收不再使用的Bitmap
4. 虚引用: 虚引用是Java中最“弱”的引用，通过它甚至无法获取被引用的对象，它存在的唯一作用就是当它指向的对象回收时，它本身会被加入到引用队列中，这样我们可以知道它指向的对象何时被销毁


### 动态代理与静态代理
1. 优点: 动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。
2. 缺点: 它始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。



