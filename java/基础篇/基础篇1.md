1. [基础篇1](https://juejin.im/post/5aa4bb1f6fb9a028b54781f4)
# 整理:

### java设计思想
1. 抽象
    1. 抽象类与接口的区别
2. 封装
3. 多态:
    1. 静态多态:重载,编译期
    2. 动态多态:重写,运行时
    3. 重写要求: 
        1. 父子类
        2. 方法名,与方法参数一致(参数个数,类型,顺序)
        3. 返回的数据类型必须是父类相同或者是其子类
        4. 访问修饰符必的限制必须要大于父类限制(public>protected>default>private)
    4. 重载要求:
        1. 方法名要相同
        2. 其他的,比如参数,返回类型,访问修饰符可以不同
4. 继承
    1. 内部类的区别
        1. 静态内部类
        2. 内部类
        3. 匿名内部类
    2. 内部类的作用
        1. 非静态内部类可以访问它的外部类对象的成员包括私有成员, 但是引用局部变量时,应该加final (为什么? 因为内部类和局部变量生命周期不同（方法结束后局部变量的生命周期就结束了，而内部类只要有引用就不结束，内部类的生命周期>=局部变量）  Java为了解决这一问题，会在编译时在内部类的构造方法里边，将局部变量作为参数传入内部类   这就造成了局部变量如果改变，内部类不知情的场景，所以要加final，保证引用不可改变   在java8中，可以不使用final关键字，但是如果我们改变局部变量的引用，编译会发生错误，从而保证了局部变量的引用不变。)

### 静态变量与成员变量的区别
```
1. 静态变量属于类，被多个实例共享，成员变量属于实例
2. 静态变量储存在方法区，成员变量在堆
3. 静态变量在类加载时候存在，成员变量在实例加载之后存在
4. 静态方法可以直接使用静态变量，不能直接使用成员变量
```

### 抽像方法,是否可以同时是静态的?是否可以同时是本地方法?是否可以被synchronized修饰?
1. 抽象方法不能是静态的,静态方法不能被子类重写,抽象方法必须被子类重写
2. 抽象方法不能是本地的,本地方法是由本地代码实现,而抽象方法是没有具体实现
3. 抽象方法不能用synchronized修饰; synchronized和方法实现的具体细节有关

### 类加载与初始化的顺序
 创建对象时构造器的调用顺序是： 父类静态初始化块 -> 子类静态初始化块 -> 父类初始化块 ->调用了父类构造器 -> 子类初始化块 -> 调用子类的构造器


 ### java中的哪些关键字
 1. transient:用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程
 2. throws,throw,try,catch,finally
 3. final,finally,finalize
    1. final 修饰类,变量,方法 (类不能被继承,方法不可被重写,变量不可变)
    2. finally 异常捕获结构中; 该语句在及其特殊的情景下,可能不执行(调用了System.exit()方法;JVM崩溃了)
    3. finalize是Object中的方法,垃圾回收时会调用该方法.

### 自动装箱和自动拆箱
1. Integer与内部类IntegerCache(如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接**引用常量池**中的Integer对象)
2. char类型变量中能不能存储一个中文汉字?  答: char类型用来存储Unicode编码的字符,unicode编码字符集中包含了汉字,所以可以的

### String与StringBuilder,StringBuffer的区别
1. String: 只读,不可变; 在拼接String的时候,使用+编译器会帮我们进行优化
2. StringBuilder: 可变,线程不安全,效率高
2. StringBuffer: 可变,线程安全,效率低
```
        String s1 = "Programming";
        String s2 = new String("Programming");
        String s3 = "Program";
        String s4 = "ming";
        String s5 = "Program" + "ming";
        String s6 = s3 + s4;
        System.out.println(s1 == s2); // false
        System.out.println(s1 == s5); //true
        System.out.println(s1 == s6); //false
        System.out.println(s1 == s6.intern()); //true
        System.out.println(s2 == s2.intern()); //false
解析：1. String是引用类型，这里 == 比较的是引用是否相同，即是否指向相同的地址
     2. 在new String对象时，会产生一个新的对象，并不会使用常量池中的字符串
     3. intern会在常量池中寻找该字符串（如果没有责新建），并返回他的地址

 String s = new String("xyz");创建了几个字符串对象？
 答: 两个对象，一个是静态区的"xyz";一个是用new创建在堆上的对象。
```
