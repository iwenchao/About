---
title: 异常
---


1. 概述：
    - Throwable
        - Error：涵盖程序不应捕获的异常，当程序触发 Error 时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。
            - OOM
            - StackOverflowError
        - Exception：程序可能需要捕获并且处理的异常。
            - 受检异常：显式捕获或声明的异常
            - 非受检异常：指 RuntimeException
2. 异常处理：异常处理的两大组成要素是抛出异常和捕获异常，这两大要素共同实现程序控制流的非正常转移。
    - catch中：Java 虚拟机会从上到下匹配异常处理器。因此，前面的 catch 代码块所捕获的异常类型不能覆盖后面的，否则编译器会报错。
    - finally中：在某些不幸的情况下，catch 代码块也触发了异常，那么 finally 代码块同样会运行，并会抛出 catch 代码块触发的异常。在某些极端不幸的情况下，finally 代码块也触发了异常，那么只好中断当前 finally 代码块的执行，并往外抛异常。

3. 实现原理：
    1. 异常实例的构造十分昂贵。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。
    2. 当然，在生成栈轨迹时，Java 虚拟机会忽略掉异常处理器以及填充栈帧的 Java 方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。
    3. 这里遍历堆栈的时候，并不用担心 inline 代码消除等编译优化对错误堆栈和代码对不上的情况，所以也就不需要先去优化之后在遍历。即时编译器生成的代码会保存原始的栈信息，以便去优化时能够复原，fillStackTrace 也会读取这些信息的，所以不需要去优化之后在 fill。
4. 那么 Java 虚拟机是如何捕获异常的？
    - 在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引，用以定位字节码。
    - 其中，from 指针和 to 指针标示了该异常处理器所指控的范围，即 try 代码块所覆盖的范围。target 指针则指向异常处理器的初始位置，例如 catch 代码块的起始位置。
    - 当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。
    - 如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者中重复上述操作。在最坏的情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。
    - finally 代码块的编译比较复杂，当前版本 Java 编译器的做法，是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中。
    - 如果 catch 代码块捕获了异常，并且触发了另外一个异常，那么 finally 捕获并重抛的异常是哪个呢？答案是后者，也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。


        
