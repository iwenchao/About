---
title: 关键字 volatile
---

#### 概述
- volatile 通常被比喻成轻量级的 synchronized，它保证了变量的可见性和有序性，但不保证原子性。但是使用 volatile 需要注意两点：
    1. 运行结果不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
    2. 变量不需要与其他的状态变量共同参与不变约束

#### volatile的原理
    
为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。

对volatile变量进行写操作的时候，jvm会向处理器发送一条lock前缀的指令，及时地将这个缓存中的变量数据写回到主存中。但是此时，由于多处理器，可能其他处理器缓存的该变量副本是过时的，那么通过**缓存一致性协议**来保证每个处理器缓存的数据在读取之前是最新的值。

- 缓存一致性协议
    - 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。
- 小结：如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。


#### volatile与可见性
- 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

- java内存模型规定了所有变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存保存了该线程中使用到的变量的主内存副本的拷贝。线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。那么不同的线程之间也就无法直接访问对方的私有内存中的变量。线程间变量的传递都需要自己的私有内存与主内存之间进行数据同步操作。所以就可能出现数据不一致情况。

- 小结：volatile提供变量在每次使用之前都是从主内存中最新的值，因此，可以使用volatile来保证多线程操作时变量的可见性。

#### volatile与有序性
- 有序性即程序执行的顺序按照代码的先后顺序执行。

- 在java内存模型中，除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load->add->save 有可能被优化成load->save->add 。这就是可能存在有序性问题。

- 而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以**禁止指令重排优化**等。

#### volatile与原子性
- 原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。

- 在多线程问题中分析过：线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于**时间片在线程间轮换**，就会发生**原子性问题**。

- 而为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile的实现中没有提供这些。所以，volatile是不能保证原子性的