1. final
    - 说起 final 关键字，脱口而出就是修饰变量变量不可变、修饰方法方法不可重写、修饰类类不可继承。
    - 或许你还听过 final 能够提高效率，那如何提高效率的呢？方法内联？方法内联又是个什么东西呢？
    - 写 final 域的重排序规则:可以确保：在对象引用为任何线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保证。
        - 
    - 读 final 域的重排序规则:
        1. JVM 禁止编译器把 final 域的写重排序到构造函数之外
        2. 编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 内存屏障，这个屏障禁止处理器把 final 域的写重排序到构造函数之外
        - 在一个线程中，初次读对象引用与初次读改对象包含的 final 域，JMM 禁止处理器重排序这两个操作。编译器会在读 final 域操作的前面插入一个 LoadLoad 内存屏障。
        - 读 final 域的重排序可以确保：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象引用。
    - 优点：
        1. 线程安全
        2. 编译器优化：
            - 编译器在对 final 修饰的方法做了方法内联。这句话对与否先不讨论，先来了解一下方法内联是什么鬼？
            - 方法内联：
                - 涉及到方法调用栈，内存模型
                    1. 首先会有个执行栈，存储它们的局部变量、方法名、动态链接地址
                    2. 当一个方法调用，一个新的栈桢会被加到栈顶，分配的本地变量和参数会存储在这个栈桢
                    3. 调转到目标方法代码执行
                    4. 方法返回的时候，本地方法和参数被销毁，栈顶被移除
                    5. 返回原来的地址执行
            - 其实这就是虚拟机栈执行方法的内存模型。函数调用需要一定的时间开销和空间开销，当一个方法被频繁调用时，这个时间和空间开销会相对变的很大。根据二八原则，80% 的性能消耗其实是发生在 20% 的代码上，对热点代码的针对优化可以提升整体系统的性能。
                - 方法内联：
                    - 热点代码
                    - 方法体不可过大：方法内联会导致拷贝代码副本过多，代码占用内存增加，所以方法体不能太大。
            - 其次由于方法可能被继承，导致需要类型检查而没有达到性能的效果，所以想要对热点代码进行方法内联，最好尽量使用 final、private、static 这些修饰方法，避免因为继承而导致额外的类型检查。

